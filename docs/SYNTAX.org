#+TITLE: Syntax recognized by mlorg
#+AUTHOR: Simon Castellan
#+EMAIL: simon.castellan@iuwt.fr
#+MACRO: demo =$1= ($1)

#+begin_abstract
=mlorg= is a parser written in OCaml for =org-mode=. It attempts to
recognize most of the syntax handled by the original =org-mode= code.
#+end_abstract
This document presents the syntax recognized by =mlorg= as well the
intended semantics (that exporters should respect) and comments on
specific exporters if it is relevant, and how the data looks like in
ML. (Although one can look at the file =syntax/common/block.ml= and
=syntax/common/inline.ml= for a documentation)

#+begin_tableofcontents
Table of contents:
#+end_tableofcontents
* A quick comment on parsing
The parsing of an org-mode file is split into two things: parsing
/block/ content (toplevel constructions such as paragraphs, lists,
tables, ...) and parsing /inline/ content contained in those blocks
(emphasis, links). The two aspects are handled completely seperately.
** Parsing blocks
The parsing of blocks is automata-based: each construction the
language gets an automata, and the parsing is line-based. When we have
no selected automaton (eg. at the beginning), we /elect/ one by
picking the first (with highest priority) that accepts the current
line and we let it run until it signals that he is done, eg. when
encoutering an empty line. However, to handle more complex documents,
automata can be interrupted when they say so, and then at each line,
one checks if an automata of higher priority is able to take it from
there. This allows to parse things like that:

: That is a paragraph. Paragraphs normally ends with an empty line, but they can
: be interrupted at any time.
: - This is the beginning of a list item, that will interrupt the paragraph.

Without interruption, one would have to add an empty line between the
paragraph and the list.
** Parsing inline contents
The parsing of inline contents is done a bit in the same way, each
construct gets a parsing function, and the parser tries to find the
best match at current point and let this match run until it's
done. There is no interruption, and free form text (ie. normal text)
is not scanned character by character but word by word (which is only
a bit more efficient). This is needed to handle constructs like [[inline
links]]. However, this could be improved by creating a lookahead table
mapping characters to parsers able to start from this character.
* Inline constructions
Inline constructions are represented in ML by the type src_ocaml{Inline.t}
** Plain
This is free form text without formatting. 
** Emphasis
=mlorg= recognizes three kind of emphasis:

- bold, introduced by =*=: {{{demo(*foo*)}}}
- italics, introduced by =/=: {{{demo(/foo/)}}}
- underline, introduced by =_=: {{{demo(_foo_)}}}


The text inside the delimiters is recursively parsed so you can nest
emphasis and other things: {{{demo(/like *that*/)}}}. 
** Entities
Entities allow you to enter unicode character by typing their LaTeX
counterpart. Entities are defined in =syntax/common/entity.ml=. In
LaTeX, they are left as is, and in HTML exported as entity.

Example: =\alpha= (\alpha)

** Export snippets
Export snippets allow you to insert a specific code for a specific
exporter. This exporter should export the string *as is* and other
exporters should ignore this. Example: {{{demo(@html{<b>html
bold</b>})}}}.

** Footnotes
Footnotes allow you to delay a comment. Their syntax is
=[fn:name:Inline definitions]=. The name and the inline definition can
be omitted (but not both of course).

Examples
- Reference to a footnote named =name= defined elsewhere: {{{demo([fn:name])}}}
- Anonymous footnote: {{{demo([fn::I have no name])}}}
- Define and make a reference to a footnote: {{{demo([fn:name:This is
  the definition of the footnote ~name~])}}}

If you define twice a footnote (with the same name), the behaviour is
unspecified.

*Note on exporters*: in LaTeX (and Beamer), footnotes are exported as
LaTeX footnotes. For other formats that do not support natively
footnotes (eg. html), the plugin Toc can rewrite footnotes into plain
org-mode constructs. See the documentation of the Toc module for more
information.

** Inline calls
Inline calls allow you to call babel programs from within inline
constructs. The syntax is
=call_program[headers](arguments)[headers]=. See the org-mode manual
for more information about the meaning of this construct. It is not
yet handled by any exporter.

** Inline source code
This allows you insert inline source code in your documents. The
syntax is as follows: =src_language[options]{code}=. No options is yet
supported.

Example: {{{demo(src_ocaml{print_endline "Hello World";;})}}}
** LaTeX fragments
You can insert inline LaTeX formula by the syntax
=$formula$=. Example: {{{demo($x + x = 2 \times x$)}}}.

This is exported as native inline formula in LaTeX, and Math2png
provides a module to rewrite these formulas into images. The HTML
exporter can either use this method or use MathJax.

You can also insert basic LaTeX commands with the following
=\command{arguments}=. It is only recognized by LaTeX-based exporters
(LaTeX, beamer).
** Break line
To insert a break line, use =\\= at the end of line.\\
This line is broken.
** Links
The general form of links in org-mode is: =[[url][description]]=. Example:
{{{demo([[http://google.fr][Google]])}}}. You can omit the URL, and it is then a link to an
anchor of the document: {{{demo([[Links]])}}}.

Links may point to:
- URLs, via the syntax ~protocol:uri~,
- local files, via the syntax ~./file~ or ~/file~,
- anchors in the present document: any string


NB: you can point to an anchor in a local file but it is likely to
work only on HTML-based backends.

On top of that, an unformatted URL will be considered as a link to
itself. The syntax is =protocol:url=. Example:
{{{http://en.wikipedia.org}}}
** Radio targets
Radio targets are inserted via =<<<radio target>>>=. =mlorg= makes no
use (at the time) of radio targets.
** Anchors (or targets)
Introduced by =<<anchor name>>=. Creates an anchor in the document the
user can refer to in a [[Links][link]].
** Subscript and superscript
They follow the same syntax as in LaTeX: =_{subscript}= and
=^{superscript}=. Examples: {{{demo(x^{y+z} = x^{y} + x^{z})}}} and
{{{demo(x_{k} = x_{0} + â€¦ + x_{k-1})}}}.
** Statistics cookies
You can use statistics cookies as in org-mode, eg. =[2/3]= or
=[%]=. Most exporters ignore it though.
** Timestamps
Timestamps are very useful in =org-mode= to define agenda and
schedules. A timestamp is of the form =<YYYY-MM-DD word>= (date)
=<YYYY-MM-DD word HH:MM>= (date and time) where word is any word
(usually an ascii representation of the week day of the corresponding
date). There are several ways to insert such timestamps in a document:

- Just as themselves. It will create a timestamp whose meaning is to
  say that this event is to happen on that day (and time),
- A range: =timestamp1--timestamp2=. To denote that the heading is spanning over several days/hours,
- =SCHEDULED: timestamp= to say that the task (heading) is scheduled to that day,
- =DEADLINE: timestamp= to say that the task (heading) is due for that
  day.
